cac bai rotate, delete thuong di cung voi searchParent(node can thay doi) hoac nodeCanDoi.left, nodeCanDoi.right
bình tĩnh đọc lại các hàm xem nên dùng hàm nào là hợp lí, có thể cần dùng cả hàm ở dòng cách khá xa

// bai phuc tap
neu la root -> truyen tham so Node root
neu khong thi dung ham
getNode by info / find nthNode
sau day se la dung nhung ham nhu height/ modify /count va truyen resNode o tren vao 

sua bug rotate(Node p, Node fp)

 ||__TRAVERSAL__//breadth-first traversal
 ||     ||______//preorder
 ||     ||______//postorder
 ||     ||______//inorder
 ||     ||______//use BFS change second node have age >=5 to age = 10
 ||     ||______//preorder with condition: 3 <= price <= 5
 ||
 ||___INSERT____//insert Node into Tree, if xForest char at 0 is B then do nothing
 ||       ||____//insert by string
 ||       ||____//insert by integer/double
 ||       ||____//insert have age > 4 use BTF
 ||
 ||___Modify given function preOrder, inOrder, postOrder, breadth to preOrder2, inOrder2, postOrder2, breadth2 with condition
 ||___SEARCH____//search
 ||       ||____//search by string
 ||       ||____//search by integer/double
 ||
 ||___COUNT_____//count node in tree
 ||       ||____//count node have 1 child   / Modify node have 1 child  
 ||       ||____//count node have exactly 2 child / Modify node have exactly 2 child 
 ||       ||____//count height of tree
 ||
 ||___DELETE____//delete by copy integer/double
 ||     ||______//delete by copy string
 ||     ||______//delete by node p
 ||
 ||___BALANCE___//balance tree
 ||     ||______//balance simple array list
 ||
 ||___ROTATE____//rotate left
 ||    ||_______//rotate right
 ||    ||_______//rotate right any node
 ||    ||_______//rotate left any node
 ||    ||_______//rotate right root 
 ||
 ||___GET_______//get node father
 ||       ||____//get node by string
 ||       ||____//get node by integer/double
 ||___OTHER_____//calculate level of node
 ||      ||_____//calculate factor
 ||      ||_____//copy all node to tree by inorder traversal
 ||      ||_____//Calculate balance factor 
 ||      ||_____//Calculate level all node
 ||      ||_____//balance a binary search tree
 ||      ||_____//modify all nodes having 1 child
 ||      ||_____//find minNode
 ||      ||_____//find maxNode
 ||      ||_____//find first node having 2 child and price < 7
 ||      ||_____//find nth node using preOrder, inOrder, postOrder
 ||      ||_____//traversal ascending order
 ||      ||_____//traversal descending order
 ||      ||_____//count internal nodes
 ||      ||_____//count leaf nodes
 ||      ||_____//visit internal nodes
 ||      ||_____//visit leaf nodes
 ||      ||_____//Calculate height of last node in postOrder traversal from the root. 
 ||      ||_____//Reset age of all nodes locate in left branch of 1st node in preOrder traversal from root to zero(age=0). 
 ||      ||_____//ModifyTreeByPostOrder
 ||      ||_____//ModifyTreeByPreOrder
 ||      ||_____//ModifyTreeByInOrder
 ||      ||_____//Reset age of each node base on level of the node    
 ||      ||_____//Inorder from root, find 2nd node having left child, delete q = p.left
 ||      ||_____//Find first node having 2 child 
 ||      ||_____//Find 5th node having 2 child 
 ||      ||_____//Find first node having 2 child using in-order traversal








   (C,8) (F,2) (E,9) (H,1) (D,6) (I,3) (G,7) (J,5) (K,4) 
//breadth-first traversal
    public void bfs(Node p){ //input root
        if(p == null) return;
        MyQueue m = new MyQueue();
        m.enqueue(p);
        while(!m.isEmpty()){
            Node q = (Node)m.dequeue();// get node
            if(q.left != null){ // if lever still hava node left
                m.enqueue(q.left);
            }
            if(q.right != null){ //if lever still hava node right
                m.enqueue(q.right);
            }
            visit(q);// traversal them
        }        
    }
	
//preorder
    public void preorder(Node p){
        if(p == null){
            return;
        }
        visit(p);
        preorder(p.left);
        preorder(p.right);
    }
	
//postorder
	public void postorder(Node p){
        if(p == null){
            return;
        }
        postorder(p.left);
        postorder(p.right);
        visit(p);
    }
	
//inorder
    public void inorder(Node p){
        if(p == null){
            return;
        }
        inorder(p.left);
        visit(p);
        inorder(p.right);
    }
 
//use BFS change second node have age >=5 to age = 10
	int c = 0;
    public void changeNodeCondition(Node p){
        if(p == null) return;
        Queue m = new Queue();// neu khong chay duoc va co class MyQueue.java thi doi Queue sang MyQueue
        m.enqueue(p);
        while(!m.isEmpty()){
            Node q = (Node)m.dequeue();
            if(q.left != null){
                m.enqueue(q.left);
            }
            if(q.right != null){
                m.enqueue(q.right);
            }
            if(q.info.age >= 5){ //maybe or not
                c++;
                if(c == 2){
                    q.info.age = 10;
                    break; 
                }
            }
        }        
    }
 
//preorder with condition: 3 <= price <= 5
   void preOrder2(Node p, RandomAccessFile f) throws Exception{
	 if(p==null) return;
     if(p.info.price>=3&&p.info.price<=5){
        fvisit(p,f);
     }
     preOrder2(p.left,f);
     preOrder2(p.right,f);
   }
	 
//insert Node into Tree, if xForest char at 0 is B then do nothing
void insert(String xForest, int xHoof, int xHair) {
 if (xForest.charAt(0) == 'B') {
            return;           			
        }
        Node q = new Node(new Bison(xForest, xHoof, xHair));
        if (isEmpty()) {
            root = q;
            return;
        }
        Node p = root;
        Node f = null; // f is the father of p
        while (p != null) {
            if (xHoof == p.info.hoof) {
                return;
            } // end if
            f = p;
            if (xHoof < p.info.hoof) {
                p = p.left;
            } else {
                p = p.right;
            }
        } // end while

        if (xHoof < f.info.hoof) {
            f.left = q;
        } else {
            f.right = q;
        }
}

//insert by string
    public void insert(Person x){
        Node p = new Node(x);
        if(isEmpty()){root = p; return;}
        Node f = null;
        Node q = root;
        while(q != null){
            if(q.info.name.equals(x.name)){
                System.out.println("Insertion failed, duplicated key");
                return;
            }
            else if(q.info.name.compareToIgnoreCase(x.name) > 0){f = q; q = q.left;}
            else{f = q; q = q.right;}
        }
        if(f.info.name.compareToIgnoreCase(x.name) > 0) f.left = p;
        else f.right = p;
    }
    
//insert by integer/double
    public void insert(Car x){
	 Node q=new Node(x);
     if(isEmpty())
      {root=q;
        return;
       }
     Node f,p;
     f=null;p=root;
     while(p!=null)
       {if(p.info.price == x.price)
          {System.out.println("The key " + x.price + " already exists, no insertion");
            return;
          }
         f=p;
         if(x.price < p.info.price) p=p.left; else p=p.right;
       } 
      if(x.price< f.info.price) f.left=q; else f.right=q;
    } 
 
//insert only nodes have age > 4 use Breadth first traversal
    public void breadthModifier(){
	if(root == null){ return; //change
            MyQueue m = new MyQueue();
            m.enqueue(root);
            while(!m.isEmpty()){
                Node q = (Node)m.dequeue();         
                if(q.left != null){
                    m.enqueue(q.left);
                }
                if(q.right != null){
                    m.enqueue(q.right);
                }
                if(q.info.age > 4){
                    h.insert(q.info);
                }
            }
		}
	}

// Modify given function preOrder, inOrder, postOrder, breadth to preOrder2, inOrder2, postOrder2, breadth2 with condition
//  output node having color < 6 using preOrder
void preOrder2(Node p, RandomAccessFile f) throws Exception {
      if(p==null) return;
      if (p.info.color<6){
          fvisit(p,f);
      }
      preOrder2(p.left,f);
      preOrder2(p.right,f);
     }

//  output node having color < 6 using inOrder
void preOrder2(Node p, RandomAccessFile f) throws Exception {
      if(p==null) return;
      preOrder2(p.left,f);
      if (p.info.color<6){
          fvisit(p,f);
      }
      preOrder2(p.right,f);
     }

//  output node having color < 6 using postOrder
void preOrder2(Node p, RandomAccessFile f) throws Exception {
      if(p==null) return;
      preOrder2(p.left,f);
      preOrder2(p.right,f);
      if (p.info.color<6){
          fvisit(p,f);
      }
     }
//  output node having color < 6 using breadth
public void breadth2(Node p, RandomAccessFile f) throws Exception {
        if(p == null) 
            return;
        Queue q = new Queue();
        q.enqueue(p);
        Node r;
        while(!q.isEmpty()) {
            r = q.dequeue();
            if(r.info.color<6){
                fvisit(r,f);
            }
            if(r.left != null) 
                q.enqueue(r.left);
            
            if(r.right != null) 
                q.enqueue(r.right);
        }
    }

 	 
 //search
    public Node search(Person x){
        return search(root, x);
    }

//search by string
    public Node search(Node p, Person x){
        if(p == null){
            return null;
        }
        if(p.info.name.equals.x.name){
            return p;
        }
        else if(p.info.name.compareToIgnoreCase(x.name) > 0){
            return search(p.left,x);
        }
        else{
            return search(p.right,x);
        }
    }
 
//search by integer/double
    public Node search(Node p, int key){
		if(p == null) return null;
		 if(p.info == key) return p;
		 else if(p.info > key) return search(p.left, key);
		 else return search(p.right, key);
		}
 
//count node in tree / size
    public int count(Node p){
	 if(p==null) return(0);
	   int k,h,r;
	   k = count(p.left);
	   h = count(p.right);
	   r = k+h+1;
	   return(r);
	 }
	
//count node have 1 child
   int countModifer(Node p) {
      int n = 0;
      MyQueue m = new MyQueue();
        m.enqueue(p);
        while(!m.isEmpty()) {
            Node q = (Node)m.dequeue();
            if(q.left != null) m.enqueue(q.left);
            if(q.right != null) m.enqueue(q.right);
            // If q has only one child, increment c by 1
            if(q.left == null && q.right != null) n++;
            if(q.right == null && q.left != null) n++;
        }
      return n;
  }
 
//count node have exactly 2 child
    int countNodeCo2con(Node p) {
      int n = 0;
      MyQueue m = new MyQueue();
        m.enqueue(p);
        while(!m.isEmpty()) {
            Node q = (Node)m.dequeue();
            if(q.left != null) m.enqueue(q.left);
            if(q.right != null) m.enqueue(q.right);
            if(q.left != null && q.right != null) n ++;
        }
      return n;
     }
  
//count height of tree
    public int height(Node p) {
        if (p == null) {
            return 0;
        }
        int l = height(p.left) + 1;
        int r = height(p.right) + 1;
        return (l > r) ? l : r;
    }
 
//delete by copy integer/ double
    public void deleByCopy(int xPrice) {
        if (root == null) {
            System.out.println(" The tree is empty, no deletion");
            return;
        }
        Node f, p; // f will be the father of p
        p = root;
        f = null;
        while (p != null) {
            if (p.info.price == xPrice) {
                break;//Found key x
            }
            if (xPrice < p.info.price) {
                f = p;
                p = p.left;
            } else {
                f = p;
                p = p.right;
            }
        }
        if (p == null) {
            System.out.println(" The key " + xPrice + " does not exist, no deletion");
            return;
        }
        if (p.left == null && p.right == null) // p is a leaf node
        {
            if (f == null) // The tree is one node
            {
                root = null;
            } else {
                if (f.left == p) {
                    f.left = null;
                } else {
                    f.right = null;
                }
            }
            return;
        }
        if (p.left != null && p.right == null) // p has only left child
        {
            if (f == null) // p is a root
            {
                root = p.left;
            } else {
                if (f.left == p) // p is a left child
                {
                    f.left = p.left;
                } else {
                    f.right = p.left;
                }
            }
            return;
        }

        if (p.left == null && p.right != null) // p has only right child
        {
            if (f == null) // p is a root
            {
                root = p.right;
            } else {
                if (f.left == p) // p is aleft child
                {
                    f.left = p.right;
                } else {
                    f.right = p.right;
                }
            }
            return;
        }
        if (p.left != null && p.right != null) // p has both left and right children
        {
            Node q, fr, rp; // p's key will be replaced by rp's one
            fr = null;
            q = p.left;
            rp = q;
            while (rp.right != null) {
                fr = rp;
                rp = rp.right; // Find the right most node on the left sub-tree
            }
            p.info = rp.info;
            if (fr == null) // rp is just a left son of p 
            {
                p.left = rp.left;
            } else {
                fr.right = rp.left;
            }
        }
    }
	
//delete by copy node have string xName
    void deleByCopy(String xName){
	 Node f,p;
     f=null;p=root;
     while(p!=null)
       {if(p.info.name.equals(xName)) break;
         f=p;
         if(xName.compareTo(p.info.name)<0) p=p.left; else p=p.right;
       }
      if(p==null) return; // not found
      
      // p is leaf node
      if(p.left==null && p.right==null)
        {if(f==null) // p=root
           {root=null;
           }
           else
            {if(p==f.left) f.left=null; f.right=null;
             }
          return;
        } 

      // p has left child only
      if(p.left!=null && p.right==null)
        {if(f==null) // p=root
           {root=p.left;
           }
           else
            {if(p==f.left) f.left=p.left; f.right=p.left;
             }
          return;
        } 

      // p has right child only
      if(p.left==null && p.right!=null)
        {if(f==null) // p=root
           {root=p.right;
           }
           else
            {if(p==f.left) f.left=p.right; f.right=p.right;
             }
          return;
        } 

      // p has both 2 children
      if(p.left!=null && p.right!=null)
        {// find the right most node
          Node q=p.left;
          Node frp, rp; frp=null;rp=q;
          while(rp.right!=null) {frp=rp;rp=rp.right;}
          // rp is the right most node on the left child
          p.info=rp.info;
          if(frp==null) // rp=q
           {p.left=q.left;
           }
           else
           {
            frp.right=rp.left; 
           }
        }
    }
 
     //delete by copy rightmost of left subtree by node

    public void deleteByCopy(Node p) {
        if (isEmpty()) {
            return;
        }
        if(p == null){
            System.out.println("Key does not exists, deletion failed");
            return;
        }
        // Find Node f where f is father of p
        Node f = null;
        Node q = root;
        while(q != p){
            if(q.info.name.compareTo(p.info.name) > 0){         // Changed
                f = q;
                q = q.left;
            }
            else{
                f = q;
                q = q.right;
            }
        }
        // 1. p is a leaf (no right and left child)
        if (p.left == null && p.right == null) {
            // a BST has a Node only
            if (f == null) {
                root = null;
            } 
            else if (f.left == p) {
                f.left = null;
            }
            else if(f.right == p){
                f.right = null;
            }
        }
        // 2. p has a left child only
        else if(p.left != null && p.right == null){
            if(f == null){// remove root
                root = p.left;
            }
            else if(f.right == p){
                f.right = p.left;
            }
            else if(f.left == p){
                f.left = p.left;
            }
        }
        // 3. p has a right child only
        else if(p.right != null && p.left == null){
            if(f == null){// remove root
                root = p.right;
            }
            else if(f.right == p){
                f.right = p.right;
            }
            else if(f.left == p){
                f.left = p.right;
            }
        }
        // 4. Both of right and left child 
        else if(p.left != null && p.right != null){
            f = null;
            Node rp = p.left;
            while(rp.right != null){
                f = rp;
                rp = rp.right;
            }
            p.info = rp.info;
            if(f == null){// rp has no right child 
                p.left = rp.left;
            }
            else{
                f.right = rp.left;
            }
        }
    }

     //delete by copy leftmost of right subtree by node
    public void deleteByCopy(Node p) {
        if (isEmpty()) {
            return;
        }
        if (p == null) {
            System.out.println("Key does not exists, deletion failed");
            return;
        }
        // Find Node f where f is father of p
        Node f = null;
        Node q = root;
        while (q != p) {
            if (q.info.name.compareTo(p.info.name) > 0) {         // Changed
                f = q;
                q = q.left;
            } else {
                f = q;
                q = q.right;
            }
        }
        // 1. p is a leaf (no right and left child)
        if (p.left == null && p.right == null) {
            // a BST has a Node only
            if (f == null) {
                root = null;
            } else if (f.left == p) {
                f.left = null;
            } else if (f.right == p) {
                f.right = null;
            }
        } // 2. p has a left child only
        else if (p.left != null && p.right == null) {
            if (f == null) {// remove root
                root = p.left;
            } else if (f.right == p) {
                f.right = p.left;
            } else if (f.left == p) {
                f.left = p.left;
            }
        } // 3. p has a right child only
        else if (p.right != null && p.left == null) {
            if (f == null) {// remove root
                root = p.right;
            } else if (f.right == p) {
                f.right = p.right;
            } else if (f.left == p) {
                f.left = p.right;
            }
        } // 4. Both of right and left child 
        else if (p.left != null && p.right != null) {
            f = null;
            Node rp = p.right;
            while (rp.left != null) {
                f = rp;
                rp = rp.left;
            }
            p.info = rp.info;
            if (f == null) {// rp has no right child 
                p.right = rp.right;
            } else {
                f.left = rp.right;
            }
        }
    }
//balance tree
    public void balance(ArrayList a, int first, int last){  
        if(first > last) return;
        int m = (first + last) /2;
        Person x = ((Node)a.get(m)).info;
        insert(x);
        balance(a, first, m-1);
        balance(a, m+1, last);
    }
	
//balance simple array list
    public void balance(Node p){
        ArrayList a = new ArrayList();
        buildArray(a, p);
        int first = 0;
        int last = a.size() - 1;
        BSTree b = new BSTree(); //create new tree 
        b.balance(a, first, last);
        root = b.root; //referen root to root b
    } 
 
p = 42
q = 16

//rotate left
    public Node rotateLeft(Node p){//must be have node right
        if(p.right == null){
            return p;
        }
        Node q = p.right;
        p.right = q.left;
        q.left = p;
        return q;
    }

//rotate right
    public Node rotateRight(Node p){
        if(p.left == null){
            return p;
        }
        Node q = p.left;
        p.left = q.right;
        q.right = p;
        return q;
    }

//rotate right any node
       public void rotateModifier(Node node){
        Node nodeRotate = rotateToRight(node);
		Node nodeFather = searchParent(node);
		if(nodeFather==null) root = nodeRotate;
        else{
			if(nodeFather.left==node) nodeFather.left = nodeRotate; 
			else  nodeFather.right = node;
         }
	}

    Node rotateToRight(Node p){//root = rotateToRight(root)
    if(p==null || p.left==null) return(p);
        Node q=p.left;
        p.left=q.right;
        q.right=p;
        return(q);
    }

Node searchParent(Node a) {
        if (a == null)
            return null;
        Node p = root, f = null;
        while (p != null && p != a) {
            f = p;
            if (p.info.weight > a.info.weight)
                p = p.left;
            else 
                p = p.right;
        }
        return f;
    }
	
//get node father
    Node father(int xPrice){
	 Node f,p;
     f=null;p=root;
     while(p!=null)
       {if(p.info.price == xPrice) break;
         f=p;
         if(xPrice < p.info.price)  p=p.left; else p=p.right;
       }
     return(f);
    } 

//tim parent
//get node father
Node searchParent(Node a) {
        if (a == null)
            return null;
        Node p = root, f = null;
        while (p != null && p != a) {
            f = p;
            if (p.info.weight > a.info.weight)
                p = p.left;
            else 
                p = p.right;
        }
        return f;
    }
	

//rotate left any node
       public void rotateModifier(Node node){
        Node nodeRotate = rotateToLeft(node);
		Node nodeFather = searchParent(node);
		if(nodeFather==null) root = nodeRotate;
        else{
			if(nodeFather.right==node) nodeFather.right = nodeRotate; 
			else  nodeFather.left = node;
         }
	}

    Node rotateToLeft(Node p){//root = rotateToLeft(root)
    if(p==null || p.right==null) return(p);
        Node q=p.right;
        p.right=q.left;
        q.left=p;
        return(q);
    }
	
  Node searchParent(Node a) {
        if (a == null)
            return null;
        Node p = root, f = null;
        while (p != null && p != a) {
            f = p;
            if (p.info.weight > a.info.weight)
                p = p.left;
            else 
                p = p.right;
        }
        return f;
    }  
//get node by string
    public Node getNode(String xName) {
        Node p = root;
        while (p != null) {
            if (p.info.name.compareToIgnoreCase(xName) > 0) p = p.left;
            else if (p.info.name.compareToIgnoreCase(xName) < 0) p = p.right;
            return p;
        }
        return null;
    }
	
//get node by integer/double
    public Node getNode(int x) {
        Node p = root;
        while (p != null) {
            if (p.info > x) p = p.left;
            else if (p.info < x) p = p.right;
            return p;
        }
        return null;
    }
 
//calculate level of node
    public void calLevel(Node p){
        if(p == null){
            return;
        }
        Queue m = new Queue(); //rename class Queue to MyQueue depends on given
        m.enqueue(p);
        p.level = 1;//first, leve = 1
        while(!m.isEmpty()){
            Node q = (Node)m.dequeue();         
            if(q.left != null){
                q.left.level = q.level +1;
                m.enqueue(q.left);
            }
            if(q.right != null){
                q.right.level = q.level +1;
                m.enqueue(q.right);
            }
            
        }        
    }

//Reset age of each node basse on level of the node    
    public void resAgeByLevel(Node p){
        if(p == null){
            return;
        }
        Queue m = new Queue(); //rename class Queue to MyQueue depends on given
        m.enqueue(p);
       
        p.info.age = 1;//first, leve = 1, consider root at level 1, if level 0 thi thay = 0
        while(!m.isEmpty()){
            Node q = (Node)m.dequeue();         
            if(q.left != null){
                q.left.info.age = q.info.age +1;
                m.enqueue(q.left);
            }
            if(q.right != null){
                q.right.info.age = q.info.age +1;
                m.enqueue(q.right);
            }
            
        }        
    }

//calculate factor
    public void calculateBalance(Node p){
        if(p == null){
            return;
        }
        MyQueue m = new MyQueue();
        m.enqueue(p);
        while(!m.isEmpty()){
            Node q = (Node)m.dequeue();         
            if(q.left != null){
                m.enqueue(q.left);
            }
            if(q.right != null){
                m.enqueue(q.right);
            }
            q.bal = height(q.right) - height(q.left); 
            if(isAVL && q.bal < -1 || q.bal > 1){// De cho  thuc hien nhieu
                isAVL = false;
            }
        }        
    }

//copy all node to tree by inorder traversal
    public void buildArray(ArrayList a, Node p){
        if(p == null){
            return;
        }
        buildArray(a, p.left);
        a.add(p);
        buildArray(a, p.right);
    }

	
//Calculate balance factor 
  void calculateFactorBalance(RandomAccessFile  f123) throws Exception{
     boolean isAVL = true;
     MyQueue q = new MyQueue();
     q.enqueue(root);Node r;
     while(!q.isEmpty())
       {r = q.dequeue();
         r.bal = height(r.right) - height(r.left);//int bal in class Node; // balance factor of the node p = height(p.right) - height(p.left)
         if(r.bal>=2 || r.bal<=-2) isAVL = false;
         if(r.left!=null) q.enqueue(r.left);
         if(r.right!=null) q.enqueue(r.right);
       }
     breadthBal(root,f123);
    if(!isAVL)
     f123.writeBytes("\r\nThe tree is not an AVL tree\r\n");
     else
      f123.writeBytes("\r\nThe tree is an AVL tree\r\n");
  }
  public void breadthBal(Node  p, RandomAccessFile f) throws Exception{//use for balance factor
	if(p==null) return;
    MyQueue q = new MyQueue();
    q.enqueue(p); Node r;
    while(!q.isEmpty())
     {r = q.dequeue();
      fvisitBal(r,f);
      if(r.left != null) q.enqueue(r.left);
      if(r.right != null) q.enqueue(r.right);
     }
   }
  void fvisitBal(Node p, RandomAccessFile f) throws Exception
    {if(p != null) 
      f.writeBytes("("+p.info.name+","+p.info.age+","+p.bal+") ");
    }
  
 //Calculate level all node
  void calculateLevelAllNode(){
	MyQueue q = new MyQueue();
    if(isEmpty()) return; 
    root.level=1;
     q.enqueue(root);Node r;
     while(!q.isEmpty())
       {r = q.dequeue();
        if(r.left!=null) r.left.level = r.level +1;//level in class node
        if(r.right!=null) r.right.level = r.level +1;
        if(r.left!=null) q.enqueue(r.left);
        if(r.right!=null) q.enqueue(r.right);
       }
    }
	void fvisitLevel(Node p, RandomAccessFile f) throws Exception
    {if(p != null) 
      f.writeBytes("("+p.info.name+","+p.info.age+","+p.level+") ");
    }

//balance a binary search tree 
	void balance(){
	 ArrayList<Person> t;
     t = new ArrayList<Person>();
     inOrder(t,root);
     int n = t.size();
     clear();
     balance(t,0,n-1);
   }
   void inOrder(ArrayList<Person> t, Node p){
	if(p==null) return;
    inOrder(t,p.left);
    t.add(p.info);
    inOrder(t,p.right);
  }
  void balance(ArrayList<Person> t, int i, int j)
  {if(i>j) return;
    int k=(i+j)/2;
    insert(t.get(k));//insert person
    balance(t,i,k-1);
    balance(t,k+1,j);
  }



    void addNodeOneChildInfo(Node p) {
        Queue m = new Queue();
        m.enqueue(p);
        while (!m.isEmpty()) {
            Node q = (Node) m.dequeue();
            if (q.left != null) {
                m.enqueue(q.left);
            }
            if (q.right != null) {
                m.enqueue(q.right);
            }
            // If q has only one child, increment c by 1
            if (q.left == null && q.right != null) {
                q.info.age += 3;
            }
            if (q.right == null && q.left != null) {
                {
                    q.info.age += 3;
                }
            };
        }
    }

//tim node thu 5   (node3 luu gia tri node can tim)
    int count3 = 0;
    Node node3 = null;
    void postOrder3(Node p) {
        if (p == null) {
            return;
        }
        
        postOrder3(p.left);
        postOrder3(p.right);
        //logic
        count3++;
        if (count3 == 5) {
            node3 = p;
            return;
        }
    }


    //find min Node, after called, minNode is assigned
    int countForMin = 0;
    Node minNode = null;

    void inOrderMin(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        inOrderMin(p.left, f);
        countForMin++;
        if (countForMin == 1) {
            minNode = p;
            return;
        }
        inOrderMin(p.right, f);

    }

    int countNode(Node pNode) {
        if (pNode == null) {
            return 0;
        }
        int k, h, rNode;
        k = countNode(pNode.left);
        h = countNode(pNode.right);
        rNode = k + h + 1;
        return rNode;
    }


//find maxNode, maxNode is the result node
int countForMax=0;
 Node maxNode = null;
 void preOrderMax(Node p, RandomAccessFile f) throws Exception {
      if(p==null) return;
      int size = this.countNode(root);
      countForMax++;
      if(countForMax==size){
          maxNode=p;
          return;
      }
      preOrderMax(p.left,f);
      preOrderMax(p.right,f);
     }
 
 int countNode(Node pNode) {
        if (pNode == null) {
            return 0;
        }
        int k, h, rNode;
        k = countNode(pNode.left);
        h = countNode(pNode.right);
        rNode = k + h + 1;
        return rNode;
    }


// changeSubtreeNode
    int count5 = 0;
    Node node5 = null;

    void preOrder5(Node p) {
        if (p == null) {
            return;
        }
        count5++;
        if (count5 == 1) {
            node5 = p;
            return;
        }
        preOrder5(p.left);
        preOrder5(p.right);
        //logic

    }

    public void changeSubtreeNode(Node p) {
        if (p == null) {
            return;
        }
        p.info.age = 0;
        changeSubtreeNode(p.left);
        changeSubtreeNode(p.right);
    }

//modify all nodes having 1 child
   void modiferAllNodesHavingOneChild(Node p) {
      int n = 0;
      Queue m = new Queue();
        m.enqueue(p);
        while(!m.isEmpty()) {
            Node q = (Node)m.dequeue();
            if(q.left != null) m.enqueue(q.left);
            if(q.right != null) m.enqueue(q.right);
            // If q has only one child
            if(q.left == null && q.right != null) q.info.age+=3;
            if(q.right == null && q.left != null) q.info.age+=3;
        }
  }
//modify all leaf nodes
   void modifyAllLeafNodes(Node p) {
      int n = 0;
      Queue m = new Queue();
        m.enqueue(p);
        while(!m.isEmpty()) {
            Node q = (Node)m.dequeue();
            if(q.left != null) m.enqueue(q.left);
            if(q.right != null) m.enqueue(q.right);
            // If q has only one child
            if(q.right == null && q.left == null) q.info.age+=3;
        }
  }
//find first node having 2 child and price < 7
    Node findFirstNodeHavingTwoSons(Node p) {
        Queue m = new Queue();
        m.enqueue(p);
        count++;
        while (!m.isEmpty()) {
            Node q = (Node) m.dequeue();
            if (q.left != null) {
                m.enqueue(q.left);
            }
            if (q.right != null) {
                m.enqueue(q.right);
            }
            if (q.left != null && q.right != null && q.info.price < 7) {
                node3 = q;
                return node3;
            }
        }
        return null;
    }

 //find nth node using preOrder, inOrder, postOrder
//tim node  nth bang cach duyet postOrder   (Node resNode luu gia tri node can tim)
// gia su loi bien count hoac 1 bien khac - > doi ten va nho doi het
    int count = 0;
    Node resNode = null;
    void nthpPostOrder(Node p) {
        if (p == null) {
            return;
        }

        nthpPostOrder(p.left);	
        nthpPostOrder(p.right);
	//logic
        count++;
            // thay vao n
        if (count == count(root)) {
            resNode = p;
            return;
        } 
    }
    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }




//tim node nth bang cach duyet PreOrder   (Node resNode luu gia tri node can tim)
// gia su loi bien count hoac 1 bien khac - > doi ten va nho doi het
    int count = 0;
    Node resNode = null;
    void nthpPreOrder(Node p) {
        if (p == null) {
            return;
        }
	//logic
        count++;
            // thay vao n
        if (count == count(root)) {
            resNode = p;
            return;
        }
        nthpPreOrder(p.left);	
        nthpPreOrder(p.right);
 
    }
    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }

//tim node nth bang cach duyet InOrder   (Node resNode luu gia tri node can tim)
// gia su loi bien count hoac 1 bien khac - > doi ten va nho doi het
    int count = 0;
    Node resNode = null;
    void nthpInOrder(Node p) {
        if (p == null) {
            return;
        }
        nthpInOrder(p.left);
	//logic
        count++;
            // thay vao n
        if (count == count(root)) {
            resNode = p;
            return;
        }	
        nthpInOrder(p.right);
 
    }
    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }

//traversal ascending order
        void ascTraversal(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        ascTraversal(p.left, f);
        fvisit(p, f);
        ascTraversal(p.right, f);
    }

//traversal descending order
        void descTraversal(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        descTraversal(p.right, f);
        fvisit(p, f);
        descTraversal(p.left, f);
    }
//find nth node using bfs, nodeNthBfs is the result node
int countNthBfs = 0;
    Node nodeNthBfs = null;

    void breadthNth(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        Queue q = new Queue();
        q.enqueue(p);
        Node r;
        while (!q.isEmpty()) {
            r = q.dequeue();
            if (r.left != null && r.info.price < 7) {
                countNthBfs++;
            }
            if (countNthBfs == 1) {
                nodeNthBfs = r;
                return;
            }
            if (r.left != null) {
                q.enqueue(r.left);
            }
            if (r.right != null) {
                q.enqueue(r.right);
            }
        }
    }
// visit all internal nodes by preOrder    
void preOrder4(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        if (p.left != null || p.right != null) {
            fvisit(p, f);
        }
        preOrder4(p.left, f);
        preOrder4(p.right, f);
    }

//count internal nodes
    int count5 = 0;
    void preOrder5(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        if (p.left != null || p.right != null) {
            count5++;
        }
        preOrder5(p.left, f);
        preOrder5(p.right, f);
    }

//count leaf nodes
    int count5 = 0;
    void preOrder5(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        if (p.left != null && p.right != null) {
            count5++;
        }
        preOrder5(p.left, f);
        preOrder5(p.right, f);
    }

//visit leaf nodes
    void preOrder4(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        if (p.left == null && p.right == null) {
            fvisit(p, f);
        }
        preOrder4(p.left, f);
        preOrder4(p.right, f);
    }

//visit internal nodes
    void preOrder4(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        if (p.left == null && p.right == null) {
            fvisit(p, f);
        }
        preOrder4(p.left, f);
        preOrder4(p.right, f);
    }


//Calculate height of last node in postOrder traversal from the root. 
    // chuyen vao ham height node p la root cua subtree de bai yeu cau
    public int height(Node p) {
        if (p == null) {
            return 0;
        }
        int l = height(p.left) + 1;
        int r = height(p.right) + 1;
        return (l > r) ? l : r;
    }

    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }


//find nth 
    //tim node thu n bang cach duyet postOrder   (Node resNode luu gia tri node can tim)
    // gia su loi bien count hoac 1 bien khac - > doi ten va nho doi het
    int count = 0;
    Node resNode = null;
    void nthpPostOrder(Node p) {
        if (p == null) {
            return;
        }

        nthpPostOrder(p.left);	
        nthpPostOrder(p.right);
	//logic
        count++;
            // thay vao n
        if (count == n) {
            resNode = p;
            return;
        } 
    }


//cach goi
//        nthpPostOrder(root); 
//        h = height(resNode);

//ModifyTreeByPreOrder
    void ModifyTreeByPreOrder(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
	//thay thong tin can sua vao
        p.info.age = 0;
        ModifyTreeByPreOrder(p.left, f);
        ModifyTreeByPreOrder(p.right, f);
    }

//ModifyTreeByInOrder
    void ModifyTreeByPreOrder(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        ModifyTreeByPreOrder(p.left, f);
	//thay thong tin can sua vao
        p.info.age = 0;
        ModifyTreeByPreOrder(p.right, f);
    }

//ModifyTreeByPostOrder
    void ModifyTreeByPreOrder(Node p, RandomAccessFile f) throws Exception {
        if (p == null) {
            return;
        }
        ModifyTreeByPreOrder(p.left, f);
        ModifyTreeByPreOrder(p.right, f);
	//thay thong tin can sua vao
        p.info.age = 0;
    }



//Inorder from root, find 2nd node having left child, delete q = p.left
// gia su loi bien count hoac 1 bien khac - > doi ten va nho doi het
    int count3 = 0;
    Node resNode3 = null;

    void nthpInOrder(Node p) {
        if (p == null) {
            return;
        }
        nthpInOrder(p.left);
        //logic
        if (p.left != null) {
            count3++;
        }
        // thay vao n
        if (count3 == 2) {
            resNode3 = p;
            return;
        }
        nthpInOrder(p.right);
    }

    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }

    //delete by copy rightmost of left subtree by node
    public void deleteByCopy(Node p) {
        if (isEmpty()) {
            return;
        }
        if (p == null) {
            System.out.println("Key does not exists, deletion failed");
            return;
        }
        // Find Node f where f is father of p
        Node f = null;
        Node q = root;
        while (q != p) {
            if (q.info.sail > p.info.sail ) {         // Changed

                    f = q;
                    q = q.left;
                } else {
                    f = q;
                    q = q.right;
                }
            }
            // 1. p is a leaf (no right and left child)
            if (p.left == null && p.right == null) {
                // a BST has a Node only
                if (f == null) {
                    root = null;
                } else if (f.left == p) {
                    f.left = null;
                } else if (f.right == p) {
                    f.right = null;
                }
            } // 2. p has a left child only
            else if (p.left != null && p.right == null) {
                if (f == null) {// remove root
                    root = p.left;
                } else if (f.right == p) {
                    f.right = p.left;
                } else if (f.left == p) {
                    f.left = p.left;
                }
            } // 3. p has a right child only
            else if (p.right != null && p.left == null) {
                if (f == null) {// remove root
                    root = p.right;
                } else if (f.right == p) {
                    f.right = p.right;
                } else if (f.left == p) {
                    f.left = p.right;
                }
            } // 4. Both of right and left child 
            else if (p.left != null && p.right != null) {
                f = null;
                Node rp = p.left;
                while (rp.right != null) {
                    f = rp;
                    rp = rp.right;
                }
                p.info = rp.info;
                if (f == null) {// rp has no right child 
                    p.left = rp.left;
                } else {
                    f.right = rp.left;
                }
            }
        }


//cach dung
        nthpInOrder(root);
        if (resNode3 != null) {
            deleteByCopy(resNode3.left);
        }



//tim node nth bang cach duyet InOrder   (Node resNode luu gia tri node can tim)
// gia su loi bien count hoac 1 bien khac - > doi ten va nho doi het
    int count3 = 0;
    Node resNode3 = null;

    void nthpInOrder(Node p) {
        if (p == null) {
            return;
        }
        nthpInOrder(p.left);
        //logic
        if (p.left != null && p.right != null) {
            count3++;
        }
        // thay vao n
        if (count3 == 1) {
            resNode3 = p;
            return;
        }
        nthpInOrder(p.right);

    }

    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }

    public void deleteByCopy(Node p) {
        if (isEmpty()) {
            return;
        }
        if (p == null) {
            System.out.println("Key does not exists, deletion failed");
            return;
        }
        // Find Node f where f is father of p
        Node f = null;
        Node q = root;
        while (q != p) {
            if (q.info.weight > p.info.weight) {         // Changed

                f = q;
                q = q.left;
            } else {
                f = q;
                q = q.right;
            }
        }
        // 1. p is a leaf (no right and left child)
        if (p.left == null && p.right == null) {
            // a BST has a Node only
            if (f == null) {
                root = null;
            } else if (f.left == p) {
                f.left = null;
            } else if (f.right == p) {
                f.right = null;
            }
        } // 2. p has a left child only
        else if (p.left != null && p.right == null) {
            p.left.info.feature = 88;
            if (f == null) {// remove root
                root = p.left;
            } else if (f.right == p) {
                f.right = p.left;
            } else if (f.left == p) {
                f.left = p.left;
            }
        } // 3. p has a right child only
        else if (p.right != null && p.left == null) {
            p.right.info.feature = 88;
            if (f == null) {// remove root
                root = p.right;
            } else if (f.right == p) {
                f.right = p.right;
            } else if (f.left == p) {
                f.left = p.right;
            }
        } // 4. Both of right and left child 
        else if (p.left != null && p.right != null) {
            f = null;
            Node rp = p.left;
            while (rp.right != null) {
                f = rp;
                rp = rp.right;
            }
            rp.info.feature = 88;
            p.info = rp.info;
            if (f == null) {// rp has no right child 
                p.left = rp.left;
            } else {
                f.right = rp.left;
            }
        }
    }

//usage
        nthpInOrder(root);
        deleteByCopy(resNode3);


//find first node having 2 child
    Node findFirstNodeHavingTwoSons(Node p) {
        Queue m = new Queue();
        m.enqueue(p);
        while (!m.isEmpty()) {
            Node q = (Node) m.dequeue();
            if (q.left != null) {
                m.enqueue(q.left);
            }
            if (q.right != null) {
                m.enqueue(q.right);
            }
            if (q.left != null && q.right != null ) {
                return q;
            }
        }
        return null;
    }

  int count = 0;
  //find 5th node having 2 child 
    Node findFirstNodeHavingTwoSons(Node p) {
        Queue m = new Queue();
        m.enqueue(p);
        while (!m.isEmpty()) {
            Node q = (Node) m.dequeue();
            if (q.left != null) {
                m.enqueue(q.left);
            }
            if (q.right != null) {
                m.enqueue(q.right);
            }
            if (q.left != null && q.right != null ) {
                count++;
//Change 5 = other number
                if(count == 5){
                    return q;
                }
            }
        }
        return null;
    }


//Find first node having 2 child using inorder

      int count = 0;
    Node resNode = null;
    void nthpInOrder(Node p) {
        if (p == null) {
            return;
        }
        nthpInOrder(p.left);
	//logic
        if(p.left != null && p.right != null){
            count++;
        }
            // thay vao n
        if (count == 1) {
            resNode = p;
            return;
        }	
        nthpInOrder(p.right);
 
    }
    // ham dem so node cua tree/subtree
    public int count(Node p) {
        if (p == null) {
            return (0);
        }
        int k, h, r;
        k = count(p.left);
        h = count(p.right);
        r = k + h + 1;
        return (r);
    }
